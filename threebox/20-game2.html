<head>
  <title>Threebox WASD driving game</title>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.6.0/mapbox-gl.css" rel="stylesheet" />
  <script src="dist/threebox.js" type="text/javascript"></script>
  <link href="20-game2.css" rel="stylesheet" />
</head>
<body>
  <div id="map" class="map"></div>
  <script type="module">
    import { onload, getPosition, keys } from './20-game2.js';
    window.onload = onload

    const position = await getPosition()
    const layerId = '3d-buildings'
    const minZoom = 12

    mapboxgl.accessToken = "pk.eyJ1IjoicmVsaWNzOSIsImEiOiJjbHMzNHlwbDIwNDczMmtvM2xhNWR0ZzVtIn0.whCzeh6XW7ju4Ja6DR0imw"

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/relics9/cm6ppb5z7000501ra6nwl5wl2',
      zoom: 18,
      center: position,
      pitch: 60,
      bearing: 38,
      antialias: true, // create the gl context with MSAA antialiasing, so custom layers are antialiased
    })

    window.tb = new Threebox(map, map.getCanvas().getContext('webgl'), {
      realSunlight: true,
      enableSelectingObjects: true,
      enableDraggingObjects: true,
      enableRotatingObjects: true,
      enableTooltips: true,
    })

    tb.setSunlight(new Date(2020, 6, 19, 23), map.getCenter())

    function createCompositeLayer() {
      return {
        id: layerId,
        source: 'composite',
        'source-layer': 'building',
        filter: ['==', 'extrude', 'true'],
        type: 'fill-extrusion',
        minzoom: minZoom,
        paint: {
          'fill-extrusion-color': ['case', ['boolean', ['feature-state', 'select'], false], 'red', ['boolean', ['feature-state', 'hover'], false], 'lightblue', '#aaa'],
          // use an 'interpolate' expression to add a smooth transition effect to the buildings as the user zooms in
          'fill-extrusion-height': ['interpolate', ['linear'], ['zoom'], minZoom, 0, minZoom + 0.05, ['get', 'height']],
          'fill-extrusion-base': ['interpolate', ['linear'], ['zoom'], minZoom, 0, minZoom + 0.05, ['get', 'min_height']],
          'fill-extrusion-opacity': 0.9,
        },
      }
    }

    // parameters to ensure the model is georeferenced correctly on the map
    let truck

    import { GUI } from 'https://threejs.org/examples/jsm/libs/lil-gui.module.min.js'
    import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js'
    let stats

    let api = {
      buildings: true,
      acceleration: 5,
      inertia: 3,
    }

    map.on('style.load', () => {
      //create the layer
      map.addLayer({
        id: '3d-model',
        type: 'custom',
        renderingMode: '3d',
        onAdd: (map, gl) => {
          tb.loadObj(
            {
              type: 'glb', //model type
              obj: './models/vehicles/car.glb',
              units: 'meters', // in meters
              scale: 5, //x3 times is real size for this model
              rotation: { x: 90, y: -90, z: 0 }, //default rotation
              anchor: 'top',
            },
            (model) => {
              truck = model.setCoords([position[0], position[1], 10])
              truck.setRotation({ x: 0, y: 0, z: -38 }) //turn it to the initial street way
              // truck.addTooltip('Drive with WASD keys', true, truck.anchor, true, 2)
              truck.castShadow = true
              truck.selected = true
              truck.addEventListener(
                'ObjectChanged',
                (e) => {
                  if (api.buildings) {
                    let point = map.project(e.detail.object.coordinates) //here's the object already modified
                    let features = map.queryRenderedFeatures(point, { layers: [layerId] })
                    if (features.length > 0) {
                      map.setFeatureState({ source: features[0].source, sourceLayer: features[0].sourceLayer, id: features[0].id }, { select: true })
                    }
                  }
                },
                false,
              )
              tb.add(truck)
              // stats
              stats = new Stats()
              map.getContainer().appendChild(stats.dom)

              animate()

              // gui
              let gui = new GUI()
              // this will define if there's a fixed zoom level for the model
              gui
                .add(api, 'buildings')
                .name('buildings')
                .onChange(() => {
                  if (api.buildings) {
                    if (!map.getLayer(layerId)) map.addLayer(createCompositeLayer())
                  } else {
                    if (map.getLayer(layerId)) map.removeLayer(layerId)
                  }
                  tb.map.repaint = true
                })
              gui.add(api, 'acceleration', 1, 10).step(0.5)
              gui.add(api, 'inertia', 1, 5).step(0.5)
            },
          )
        },
        render: (gl, matrix) => {
          tb.update()
        },
      })

      if (api.buildings) {
        if (!map.getLayer(layerId)) {
          map.addLayer(createCompositeLayer())
        }
      }

      map.getCanvas().focus()
    })

    let velocity = 0.0
    let speed = 0.0
    let ds = 0.01

    function animate() {
      requestAnimationFrame(animate)
      stats.update()
      speed = 0.0
      if (!(keys.w || keys.s)) {
        if (velocity > 0) {
          speed = -api.inertia * ds
        } else if (velocity < 0) {
          speed = api.inertia * ds
        }
        if (velocity > -0.0008 && velocity < 0.0008) {
          speed = velocity = 0.0
          return
        }
      }
      if (keys.w) speed = api.acceleration * ds
      else if (keys.s) speed = -api.acceleration * ds
      velocity += (speed - velocity) * api.acceleration * ds
      if (speed == 0.0) {
        velocity = 0
        return
      }
      truck.set({ worldTranslate: new THREE.Vector3(0, -velocity, 0) })
      let options = {
        center: truck.coordinates,
        bearing: map.getBearing(),
        easing: (t) => {
          return t * (2 - t)
        },
      }
      function toDeg(rad) {
        return (rad / Math.PI) * 180
      }
      function toRad(deg) {
        return (deg * Math.PI) / 180
      }
      let deg = 1
      let rad = toRad(deg)
      let zAxis = new THREE.Vector3(0, 0, 1)
      if (keys.a || keys.d) {
        rad *= keys.d ? -1 : 1
        truck.set({ quaternion: [zAxis, truck.rotation.z + rad] })
        options.bearing = -toDeg(truck.rotation.z)
      }
      map.jumpTo(options)
      tb.map.update = true
    }
  </script>
</body>
